<!DOCTYPE html>
<html lang="en">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>PRNG-MT19937分析 - Chromos2me&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.jpg">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="PRNG-MT19937分析 - Chromos2me&#39;s Blog" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="http://chromos2me.github.io/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2025-05-08T11:42:52.000Z" />
  
  <meta property="og:article:author" content="Chromos2me" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<meta name="generator" content="Hexo 7.3.0"></head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="always"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Chromos2me&#39;s Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/categories">Categories</a>
            
            
            
            <a class="nav-item" href="/tags">Tags</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/Chromos2me" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        
        <div class="categories text-uppercase">
        
            <a href="/categories/Crypto/">Crypto</a>
        
        </div>
        

        
        <div class="date" id="date">
            <span>May</span>
            <span>8,</span>
            <span>2025</span>
        </div>
        

        <h1 class="title">PRNG-MT19937分析</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h2 id="随机数生成过程"><a href="#随机数生成过程" class="headerlink" title="随机数生成过程"></a>随机数生成过程</h2><ol>
<li>从种子生成初始状态数组</li>
<li>更新状态以获得新的内部状态</li>
<li>当需要生成一个数字时，返回一个经过回火的状态值(tempered state value)</li>
<li>当所有状态值都被使用完后，返回步骤 2</li>
</ol>
<h2 id="数字生成过程"><a href="#数字生成过程" class="headerlink" title="数字生成过程"></a>数字生成过程</h2><p>给出底层数字生成的代码实现<code>genrand_uint32</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* generates a random number on [0,0xffffffff]-interval */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">genrand_uint32</span><span class="params">(RandomObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">uint32_t</span> *mt;</span><br><span class="line"></span><br><span class="line">    mt = self-&gt;state;    </span><br><span class="line">    <span class="keyword">if</span> (self-&gt;index &gt;= N) &#123;</span><br><span class="line">        <span class="comment">// state update</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y = mt[self-&gt;index++];</span><br><span class="line">    y ^= (y &gt;&gt; <span class="number">11</span>);</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span>U;</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span>U;</span><br><span class="line">    y ^= (y &gt;&gt; <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量<code>y</code>是最终返回的随机数结果，<code>mt</code> 是指向状态数组的指针，保存了当前生成器的状态（通常是长度为 624 的数组）</p>
<p>我们看一下其中的一些代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt = self-&gt;state;</span><br></pre></td></tr></table></figure>
<p>这里将指向状态数组的指针赋给 <code>mt</code>，这是梅森旋转算法的核心状态数组</p>
<p>代码中if判断的那一步先跳过，后续会介绍状态使用完时应该如何进行状态数组的更新，这里只要先知道624个随机数结果输出后需要对其进行更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = mt[self-&gt;index++]</span><br></pre></td></tr></table></figure>
<p>这里从状态数组取出下一个状态值，并自增<code>index</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y ^= (y &gt;&gt; <span class="number">11</span>);</span><br><span class="line">y ^= (y &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span>U;</span><br><span class="line">y ^= (y &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span>U;</span><br><span class="line">y ^= (y &gt;&gt; <span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p>这几行代码进行了一系列按位异或和位移操作，也就是上面所提到的<strong>tempering</strong>回火操作，用来提升输出的随机性，MT19937可被攻击的关键就是回火操作可逆，可利用以下python代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftRight</span>(<span class="params">x, shift</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ res &gt;&gt; shift</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftLeft</span>(<span class="params">x, shift, mask</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ (res &lt;&lt; shift &amp; mask)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">v</span>):</span><br><span class="line">    v = unshiftRight(v, <span class="number">18</span>)</span><br><span class="line">    v = unshiftLeft(v, <span class="number">15</span>, <span class="number">0xefc60000</span>)</span><br><span class="line">    v = unshiftLeft(v, <span class="number">7</span>, <span class="number">0x9d2c5680</span>)</span><br><span class="line">    v = unshiftRight(v, <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<p>我们详细的讲一下恢复的过程，这里我们举一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0b10101010</span>  <span class="comment"># 原始值</span></span><br><span class="line">x &gt;&gt; <span class="number">3</span> = <span class="number">0b00010101</span></span><br><span class="line">x ^ (x &gt;&gt; <span class="number">3</span>) = y = <span class="number">0b10111111</span></span><br></pre></td></tr></table></figure>
<p>从上面的右移操作可知，高位的值被传递到了位移后的低位，在传递的过程中空出的高位用0来填充，那么我们根据异或的性质：</p>
<script type="math/tex; mode=display">
0\oplus any=any</script><p>可知原始$x$和移位$x$的异或结果的高位(位数与移位数量一致)与原始$x$一致，现在我们知道tempering操作的右移式子如下所示：</p>
<script type="math/tex; mode=display">
y = x \oplus (x >> 11)</script><p>那么 $y$ 的高位和原始$x$的高位一致，我们现在只有$y$，目的是恢复原始的$x$，还以上面的移位三位为例，我们有如下表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>位索引</th>
<th>y[i]</th>
<th>x[i]</th>
<th>x[i+3]</th>
<th>y[i] = x[i] ^ x[i+3]</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0–2</td>
<td>y[i]</td>
<td>x[i]</td>
<td>?</td>
<td>y[i] = x[i]</td>
<td>x和y高位一致</td>
</tr>
<tr>
<td>3</td>
<td>y[3]</td>
<td>x[3]</td>
<td>x[0]</td>
<td>x[3] = y[3] ^ x[0]</td>
<td>因为x右移了三位，最高位落到了移位后的第4位</td>
</tr>
<tr>
<td>4</td>
<td>y[4]</td>
<td>x[4]</td>
<td>x[1]</td>
<td>x[4] = y[4] ^ x[1]</td>
<td>x第二位落到了移位后的第5位</td>
</tr>
<tr>
<td>5</td>
<td>y[5]</td>
<td>x[5]</td>
<td>x[2]</td>
<td>x[5] = y[5] ^ x[2]</td>
<td>x第三位落到了移位后的第6位</td>
</tr>
<tr>
<td>6</td>
<td>y[6]</td>
<td>x[6]</td>
<td>x[3]</td>
<td>x[6] = y[6] ^ x[3]</td>
<td>依赖之前恢复的 x[3]</td>
</tr>
<tr>
<td>7</td>
<td>y[7]</td>
<td>x[7]</td>
<td>x[4]</td>
<td>x[7] = y[7] ^ x[4]</td>
<td>依赖 x[4]</td>
</tr>
</tbody>
</table>
</div>
<p>由上面的图表可知，每次恢复的每一位均依赖已知的 $x$ 高位和已知的 $y$ 相异或得到，因此对于整个tempering操作，无论是左移还是右移均可被我们恢复，因此它是可逆的</p>
<p>利用获取到的 624 个连续的 32 位输出我们可对PRNG进行预测，因为我们已经还原了整个PRNG的内部状态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆向 tempering过程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftRight</span>(<span class="params">x, shift</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ res &gt;&gt; shift</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftLeft</span>(<span class="params">x, shift, mask</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ (res &lt;&lt; shift &amp; mask)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">v</span>):</span><br><span class="line">    v = unshiftRight(v, <span class="number">18</span>)</span><br><span class="line">    v = unshiftLeft(v, <span class="number">15</span>, <span class="number">0xefc60000</span>)</span><br><span class="line">    v = unshiftLeft(v, <span class="number">7</span>, <span class="number">0x9d2c5680</span>)</span><br><span class="line">    v = unshiftRight(v, <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myseed = <span class="built_in">int</span>(<span class="string">b&#x27;Chromos2me&#x27;</span>.<span class="built_in">hex</span>(), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(myseed)</span><br><span class="line">random.seed(myseed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些未知的输出</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(myseed):</span><br><span class="line">    random.getrandbits(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获 624 个连续的 32 位输出</span></span><br><span class="line">state = [untemper(random.getrandbits(<span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正常情况的输出 :&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.randbytes(<span class="number">4</span>).<span class="built_in">hex</span>())</span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n预测输出 :&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用逆向 tempering过程的结果设置random内部状态</span></span><br><span class="line">random.setstate((<span class="number">3</span>, <span class="built_in">tuple</span>(state + [<span class="number">624</span>]), <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.randbytes(<span class="number">4</span>).<span class="built_in">hex</span>())</span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>, <span class="number">100000</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250503181701.png" alt="微信截图_20250503181701"></p>
<h2 id="内部状态更新过程"><a href="#内部状态更新过程" class="headerlink" title="内部状态更新过程"></a>内部状态更新过程</h2><p>状态更新过程也在<code>genrand_uint32</code> 函数中，每624个输出执行一次更新，还有一种情况是在种子初始化之后第一次生成随机数时，上面的代码中我们并未给出具体执行更新操作的代码，详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 624</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 397    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_A 0x9908b0dfU    <span class="comment">/* constant vector a */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPPER_MASK 0x80000000U  <span class="comment">/* most significant w-r bits */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWER_MASK 0x7fffffffU  <span class="comment">/* least significant r bits */</span></span></span><br><span class="line"><span class="comment">/* generates a random number on [0,0xffffffff]-interval */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">genrand_uint32</span><span class="params">(RandomObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> y;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> mag01[<span class="number">2</span>] = &#123;<span class="number">0x0</span>U, MATRIX_A&#125;;</span><br><span class="line">    <span class="comment">/* mag01[x] = x * MATRIX_A  for x=0,1 */</span></span><br><span class="line">    <span class="type">uint32_t</span> *mt;</span><br><span class="line"></span><br><span class="line">    mt = self-&gt;state;</span><br><span class="line">    <span class="keyword">if</span> (self-&gt;index &gt;= N) &#123; <span class="comment">/* generate N words at one time */</span></span><br><span class="line">        <span class="type">int</span> kk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (kk=<span class="number">0</span>;kk&lt;N-M;kk++) &#123;</span><br><span class="line">            y = (mt[kk]&amp;UPPER_MASK)|(mt[kk+<span class="number">1</span>]&amp;LOWER_MASK);</span><br><span class="line">            mt[kk] = mt[kk+M] ^ (y &gt;&gt; <span class="number">1</span>) ^ mag01[y &amp; <span class="number">0x1</span>U];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;kk&lt;N<span class="number">-1</span>;kk++) &#123;</span><br><span class="line">            y = (mt[kk]&amp;UPPER_MASK)|(mt[kk+<span class="number">1</span>]&amp;LOWER_MASK);</span><br><span class="line">            mt[kk] = mt[kk+(M-N)] ^ (y &gt;&gt; <span class="number">1</span>) ^ mag01[y &amp; <span class="number">0x1</span>U];</span><br><span class="line">        &#125;</span><br><span class="line">        y = (mt[N<span class="number">-1</span>]&amp;UPPER_MASK)|(mt[<span class="number">0</span>]&amp;LOWER_MASK);</span><br><span class="line">        mt[N<span class="number">-1</span>] = mt[M<span class="number">-1</span>] ^ (y &gt;&gt; <span class="number">1</span>) ^ mag01[y &amp; <span class="number">0x1</span>U];</span><br><span class="line"></span><br><span class="line">        self-&gt;index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tempering</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来在处理内部状态更新的时候比较复杂，先简单介绍一下twist主要过程：</p>
<ul>
<li>第一个循环处理未超出状态数组的部分，实际上处理的是<code>kk = 0</code> 到 <code>kk = N-M-1</code>（即 <code>kk = 0-&gt;226</code>）<ul>
<li>定义变量kk作为数组中的索引，利用与运算将状态数组的第kk个的最高位（0x80000000的二进制为0b10000000000000000000000000000000，即32位上是1，其余位舍弃），第kk+1个的低31位（0x7fffffff的二进制为0b1111111111111111111111111111111，31位1，舍弃最高位）拼接起来，形成一个32位的组合值 $y$</li>
<li>为了得到新的状态数组的第kk位，我们需要利用到mag01数组，mag01数组根据 y 的最低位判断所异或的值，若y最低位为1，则异或常量MATRIX_A，否则异或0</li>
<li>新的状态数组第kk个是kk+M个（M是定义的常量跳跃步长）异或y右移一位异或mag01判断后的值</li>
</ul>
</li>
<li>第二个循环处理的是数组索引超出的情况，实际上处理的是<code>kk = N-M</code> 到 <code>kk = N-2</code>（即 <code>kk = 227-&gt;622</code>）<ul>
<li>和上个循环的操作一致，只是处理的是靠后的状态数组</li>
</ul>
</li>
<li>我们发现到现在就剩下最后一个623索引处的数组元素<ul>
<li>这里 y 的生成是通过<code>mt[623]</code>和<code>mt[0]</code>的组合</li>
<li><code>mt[N-1] = mt[M-1] ^ (y &gt;&gt; 1) ^ mag01[y &amp; 0x1U];</code>这一步又回绕到第397个元素（<code>mt[M-1] = mt[396]</code>）</li>
</ul>
</li>
</ul>
<p>我们将<code>(y &gt;&gt; 1) ^ mag01[y &amp; 0x1U]</code>这一部分称为 twist 过程，我们将其变为双变量函数的形式以便于我们理解：</p>
<p>注：<code>x</code>表示mt[kk]，<code>y</code>表示mt[kk+1]</p>
<script type="math/tex; mode=display">
f(x)=\left\{\begin{array}{ll}
((x \& 0 \mathrm{x} 80000000) \mid(y \& 0 \mathrm{x} 7 \mathrm{fffffff})) \gg 1 & y \& 1=0 \\
(((x \& 0 \mathrm{x} 80000000) \mid(y \& 0 \mathrm{x} 7 \mathrm{ffffff})) \gg 1) \oplus 0 \mathrm{x} 9908b0df & y \& 1=1
\end{array}\right.</script><p>接下来令初始状态为$I$，当前状态为 $S$，我们可从初始状态推出完整的内部更新过程：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S_{i} & =I_{i+397} \oplus f\left(I_{i}, I_{i+1}\right) & \forall i \in[0,226] \qquad (1)\\ 
S_{j} & =S_{j-227} \oplus f\left(I_{j}, I_{j+1}\right) & \forall j \in[227,622] \qquad (2)\\
S_{623} & =S_{396} \oplus f\left(I_{623}, S_{0}\right) & \qquad(3)
\end{aligned}</script><p>注意到$(2)$中</p>
<script type="math/tex; mode=display">
S_{227}=S_0\oplus f(I_{227},I_{228}) \\
S_{227}\oplus S_0=f(I_{227},I_{228})</script><p>很明显 $f(x,y)$ 主要依赖于 $y$，如果我们知道了第 228 次生成的输出伪随机数，我们实际上可以：</p>
<ul>
<li>恢复出第 227 个状态值的最高有效位</li>
<li>恢复出第 228 个状态值的低 31 位</li>
</ul>
<p>我们这里讨论python中的特别之处，$f$ 中的条件异或依赖于$I_{228}$的 LSB</p>
<p>下面给出进行twist逆转的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invertStep</span>(<span class="params">si, si227</span>):</span><br><span class="line">    <span class="comment"># S[i] ^ S[i-227] == (((I[i] &amp; 0x80000000) | (I[i+1] &amp; 0x7FFFFFFF)) &gt;&gt; 1) ^ (0x9908b0df if I[i+1] &amp; 1 else 0)</span></span><br><span class="line">    X = si ^ si227</span><br><span class="line">    <span class="comment"># we know the LSB of I[i+1] because MSB of 0x9908b0df is set, we can see if the XOR has been applied</span></span><br><span class="line">    mti1 = (X &amp; <span class="number">0x80000000</span>) &gt;&gt; <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> mti1:</span><br><span class="line">        X ^= <span class="number">0x9908b0df</span></span><br><span class="line">    <span class="comment"># undo shift right</span></span><br><span class="line">    X &lt;&lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment"># now recover MSB of state I[i]</span></span><br><span class="line">    mti = X &amp; <span class="number">0x80000000</span> </span><br><span class="line">    <span class="comment"># recover the rest of state I[i+1]</span></span><br><span class="line">    mti1 += X &amp; <span class="number">0x7FFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> mti, mti1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>random.getstate()</code> 返回一个内部状态元组，其中 <code>[1]</code> 是 Mersenne Twister 的内部状态数组（共 624 + 1 个元素，第一个是 index）</p>
<p>调用一次 <code>random.random()</code>，这会：</p>
<ul>
<li>从当前状态数组中生成一个伪随机数（浮点数）</li>
<li>并推进 Mersenne Twister 的状态</li>
<li>如果这次调用跨越了 624 个数字的边界，会触发一次twist</li>
</ul>
</blockquote>
<p>我们解释一下这个代码：</p>
<ul>
<li><p>函数需要传入两个状态 $S<em>i$ 和 $S</em>{i-227}$</p>
</li>
<li><p>还原 twist 使用的 y 值，原公式$S[i] = S[i-227] \oplus ((y &gt;&gt; 1) \oplus mag01[y \&amp; 1])$，这里的$X$由下面推出</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(y &gt;&gt; 1) ^ mag01 = S[i] ^ S[i - 227]</span><br><span class="line"><span class="code">                 = X</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断是否异或了0x9908b0df？</p>
<ul>
<li>我们没有 $y$，不能直接计算 $y \&amp; 1$，但是我们可以利用 $X$ 的最高位去判断</li>
<li>因为 0x9908b0df 的二进制是0b10011001000010001011000011011111，同时因为 $y$ 会进行右移，高位补0，因此若 $X$ 的最高位若为1，即可判断异或了 0x9908b0df</li>
</ul>
</li>
</ul>
<p>恢复多组初始状态值代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invertStep</span>(<span class="params">si, si227</span>):</span><br><span class="line">    <span class="comment"># S[i] ^ S[i-227] == (((I[i] &amp; 0x80000000) | (I[i+1] &amp; 0x7FFFFFFF)) &gt;&gt; 1) ^ (0x9908b0df if I[i+1] &amp; 1 else 0)</span></span><br><span class="line">    X = si ^ si227</span><br><span class="line">    <span class="comment"># we know the LSB of I[i+1] because MSB of 0x9908b0df is set, we can see if the XOR has been applied</span></span><br><span class="line">    mti1 = (X &amp; <span class="number">0x80000000</span>) &gt;&gt; <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> mti1:</span><br><span class="line">        X ^= <span class="number">0x9908b0df</span></span><br><span class="line">    <span class="comment"># undo shift right</span></span><br><span class="line">    X &lt;&lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment"># now recover MSB of state I[i]</span></span><br><span class="line">    mti = X &amp; <span class="number">0x80000000</span></span><br><span class="line">    <span class="comment"># recover the rest of state I[i+1]</span></span><br><span class="line">    mti1 += X &amp; <span class="number">0x7FFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> mti, mti1</span><br><span class="line"></span><br><span class="line">I = random.getstate()[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># this will force a state update</span></span><br><span class="line">random.random()</span><br><span class="line">S = random.getstate()[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">227</span>, <span class="number">240</span>):</span><br><span class="line">    Ii, Ii1 = invertStep(S[i], S[i-<span class="number">227</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;Ii&#125;</span> == <span class="subst">&#123;I[i]&amp;<span class="number">0x80000000</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;Ii1&#125;</span> == <span class="subst">&#123;I[i+<span class="number">1</span>]&amp;<span class="number">0x7FFFFFFF</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Python-的内部种子生成机制"><a href="#Python-的内部种子生成机制" class="headerlink" title="Python 的内部种子生成机制"></a>Python 的内部种子生成机制</h2><p>为了理解python下的种子机制，我们看一下<code>Random</code>类中的seed方法是如何实现的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Random</span>(_random.Random):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">seed</span>(<span class="params">self, a=<span class="literal">None</span>, version=<span class="number">2</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize internal state from a seed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The only supported seed types are None, int, float,</span></span><br><span class="line"><span class="string">        str, bytes, and bytearray.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        None or no argument seeds from current time or from an operating</span></span><br><span class="line"><span class="string">        system specific randomness source if available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If *a* is an int, all bits are used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        For version 2 (the default), all of the bits are used if *a* is a str,</span></span><br><span class="line"><span class="string">        bytes, or bytearray.  For version 1 (provided for reproducing random</span></span><br><span class="line"><span class="string">        sequences from older versions of Python), the algorithm for str and</span></span><br><span class="line"><span class="string">        bytes generates a narrower range of seeds.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> version == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">isinstance</span>(a, (<span class="built_in">str</span>, <span class="built_in">bytes</span>)):</span><br><span class="line">            a = a.decode(<span class="string">&#x27;latin-1&#x27;</span>) <span class="keyword">if</span> <span class="built_in">isinstance</span>(a, <span class="built_in">bytes</span>) <span class="keyword">else</span> a</span><br><span class="line">            x = <span class="built_in">ord</span>(a[<span class="number">0</span>]) &lt;&lt; <span class="number">7</span> <span class="keyword">if</span> a <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">ord</span>, a):</span><br><span class="line">                x = ((<span class="number">1000003</span> * x) ^ c) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">            x ^= <span class="built_in">len</span>(a)</span><br><span class="line">            a = -<span class="number">2</span> <span class="keyword">if</span> x == -<span class="number">1</span> <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> version == <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">isinstance</span>(a, (<span class="built_in">str</span>, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(a, <span class="built_in">str</span>):</span><br><span class="line">                a = a.encode()</span><br><span class="line">            a = <span class="built_in">int</span>.from_bytes(a + _sha512(a).digest(), <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(a, (<span class="built_in">type</span>(<span class="literal">None</span>), <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">str</span>, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>)):</span><br><span class="line">            _warn(<span class="string">&#x27;Seeding based on hashing is deprecated\n&#x27;</span></span><br><span class="line">                  <span class="string">&#x27;since Python 3.9 and will be removed in a subsequent &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;version. The only \n&#x27;</span></span><br><span class="line">                  <span class="string">&#x27;supported seed types are: None, &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;int, float, str, bytes, and bytearray.&#x27;</span>,</span><br><span class="line">                  DeprecationWarning, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>().seed(a)</span><br><span class="line">        self.gauss_next = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>我们可以利用<code>random.seed</code> 函数手动为随机数生成器设置种子，同时这个函数在导入<code>random</code> 模块时会被自动调用，用于初始化PRNG。自动设置种子的情况下，参数<code>a</code>，即我们所说的种子为None。</p>
<p><code>seed</code>函数内部在实现时存在两个版本的初始化过程，版本1兼容老版python，会将<code>str</code> 或 <code>bytes</code>哈希成一个64位整数，生成方式类似python的哈希算法，用于将字符串或者字节串形式的种子变成一个整数用于初始化。</p>
<p>版本2支持<code>str</code>，<code>bytes</code>，<code>bytearray</code>，首先将字符串编码成字节，拼接字节对象和自己的sha512哈希，然后转为一个大端整数作为种子。</p>
<p><strong>注：当使用 <code>int</code>、<code>float</code> 或 <code>None</code> 类型进行种子初始化时，种子会被直接传递给内部的种子设置过程。</strong></p>
<p>下面就可以举一个利用等价种子的例子来验证seed内部的运行过程和我们上面说到的一致（VERSION == 2）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">random.seed(<span class="string">&#x27;my seed&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(random.randbytes(<span class="number">32</span>).<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">sha_512 = hashlib.sha512(<span class="string">&#x27;my seed&#x27;</span>.encode()).digest().<span class="built_in">hex</span>()</span><br><span class="line">hex_str = <span class="string">&#x27;my seed&#x27;</span>.encode().<span class="built_in">hex</span>()</span><br><span class="line"><span class="comment"># print(sha_512)  c046d02141256723ba893a44f1a54538aba62218287bc56767433568ca7548571fe1760ba924e2f8b1e9e8887814c985f3827c68fdb09e639f313ec1c83476be</span></span><br><span class="line"><span class="comment"># print(hex_str)  6d792073656564</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价种子 0x6d792073656564c046d02141256723ba893a44f1a54538aba62218287bc56767433568ca7548571fe1760ba924e2f8b1e9e8887814c985f3827c68fdb09e639f313ec1c83476be</span></span><br><span class="line">equivalent_seed = <span class="number">0x6d792073656564c046d02141256723ba893a44f1a54538aba62218287bc56767433568ca7548571fe1760ba924e2f8b1e9e8887814c985f3827c68fdb09e639f313ec1c83476be</span></span><br><span class="line">random.seed(equivalent_seed)</span><br><span class="line"><span class="built_in">print</span>(random.randbytes(<span class="number">32</span>).<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250504170914.png" alt="微信截图_20250504170914"></p>
<p>实际上在Random类底层调用<code>_randommodule.c</code>的 <code>random_seed</code> 函数实现<code>Random.seed</code></p>
<p>默认情况使用<code>None</code>进行种子生成，将会执行下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg == <span class="literal">NULL</span> || arg == Py_None) &#123;</span><br><span class="line">    <span class="keyword">if</span> (random_seed_urandom(self) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Reading system entropy failed, fall back on the worst entropy:</span></span><br><span class="line"><span class="comment">            use the current time and process identifier. */</span></span><br><span class="line">        <span class="keyword">if</span> (random_seed_time_pid(self) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PRNG优先使用操作系统提供的加密安全伪随机数生成器（CSPRNG）进行种子初始化，这些来源的随机数足够不可预测，可以用于密码学用途，比如密钥、Token生成等；如果系统不支持这些加密安全接口，或者接口调用失败（例如沙盒限制、权限问题），Python 会降级使用较弱的熵源，如当前时间和PID</p>
<h3 id="利用CSPRNG"><a href="#利用CSPRNG" class="headerlink" title="利用CSPRNG"></a>利用CSPRNG</h3><p>系统特定的种子初始化过程由以下函数负责处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">random_seed_urandom</span><span class="params">(RandomObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> key[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_PyOS_URandomNonblock(key, <span class="keyword">sizeof</span>(key)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    init_by_array(self, key, Py_ARRAY_LENGTH(key));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于熵源的详细信息如下摘自 <code>pyurandom</code> 函数的文档字符串：</p>
<blockquote>
<p>Used sources of entropy ordered by preference, preferred source first:</p>
<ul>
<li>BCryptGenRandom() on Windows</li>
<li>getrandom() function (ex: Linux and Solaris): call py_getrandom()</li>
<li>getentropy() function (ex: OpenBSD): call py_getentropy()</li>
<li>/dev/urandom device</li>
</ul>
</blockquote>
<p>系统 CSPRNG 用于生成 624 个 32 位整数，足以填充 MT PRNG 的整个状态，但这只是初始化工作的一部分，剩余工作由<code>init_by_array</code>完成</p>
<h3 id="利用时间-PID"><a href="#利用时间-PID" class="headerlink" title="利用时间+PID"></a>利用时间+PID</h3><p>降级熵源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">random_seed_time_pid</span><span class="params">(RandomObject *self)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyTime_t now;</span><br><span class="line">    <span class="keyword">if</span> (PyTime_Time(&amp;now) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> key[<span class="number">5</span>];</span><br><span class="line">    key[<span class="number">0</span>] = (<span class="type">uint32_t</span>)(now &amp; <span class="number">0xffffffff</span>U);</span><br><span class="line">    key[<span class="number">1</span>] = (<span class="type">uint32_t</span>)(now &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(MS_WINDOWS) &amp;&amp; !defined(MS_WINDOWS_DESKTOP) &amp;&amp; !defined(MS_WINDOWS_SYSTEM)</span></span><br><span class="line">    key[<span class="number">2</span>] = (<span class="type">uint32_t</span>)GetCurrentProcessId();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(HAVE_GETPID)</span></span><br><span class="line">    key[<span class="number">2</span>] = (<span class="type">uint32_t</span>)getpid();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    key[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyTime_Monotonic(&amp;now) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key[<span class="number">3</span>] = (<span class="type">uint32_t</span>)(now &amp; <span class="number">0xffffffff</span>U);</span><br><span class="line">    key[<span class="number">4</span>] = (<span class="type">uint32_t</span>)(now &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    init_by_array(self, key, Py_ARRAY_LENGTH(key));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此过程生成四个 32 位整数，这些整数再次用于使用 <code>init_by_array</code> 函数初始化 MT PRNG 的内部状态。（生成数组较小，理想情况下只有128位熵，较差情况取决于当前时间和PID是否被成功猜测出来）</p>
<h3 id="直接利用数字"><a href="#直接利用数字" class="headerlink" title="直接利用数字"></a>直接利用数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This algorithm relies on the number being unsigned.</span></span><br><span class="line"><span class="comment"> * So: if the arg is a PyLong, use its absolute value.</span></span><br><span class="line"><span class="comment"> * Otherwise use its hash value, cast to unsigned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (PyLong_CheckExact(arg)) &#123;</span><br><span class="line">    n = PyNumber_Absolute(arg);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PyLong_Check(arg)) &#123;</span><br><span class="line">    <span class="comment">/* Calling int.__abs__() prevents calling arg.__abs__(), which might</span></span><br><span class="line"><span class="comment">        return an invalid value. See issue #31478. */</span></span><br><span class="line">    _randomstate *state = _randomstate_type(Py_TYPE(self));</span><br><span class="line">    n = PyObject_CallOneArg(state-&gt;Long___abs__, arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Py_hash_t hash = PyObject_Hash(arg);</span><br><span class="line">    <span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    n = PyLong_FromSize_t((<span class="type">size_t</span>)hash);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">goto</span> Done;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now split n into 32-bit chunks, from the right. */</span></span><br><span class="line">bits = _PyLong_NumBits(n);</span><br><span class="line"><span class="keyword">if</span> (bits == (<span class="type">size_t</span>)<span class="number">-1</span> &amp;&amp; PyErr_Occurred())</span><br><span class="line">    <span class="keyword">goto</span> Done;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Figure out how many 32-bit chunks this gives us. */</span></span><br><span class="line">keyused = bits == <span class="number">0</span> ? <span class="number">1</span> : (bits - <span class="number">1</span>) / <span class="number">32</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert seed to byte sequence. */</span></span><br><span class="line">key = (<span class="type">uint32_t</span> *)PyMem_Malloc((<span class="type">size_t</span>)<span class="number">4</span> * keyused);</span><br><span class="line"><span class="keyword">if</span> (key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    PyErr_NoMemory();</span><br><span class="line">    <span class="keyword">goto</span> Done;</span><br><span class="line">&#125;</span><br><span class="line">res = _PyLong_AsByteArray((PyLongObject *)n,</span><br><span class="line">                            (<span class="type">unsigned</span> <span class="type">char</span> *)key, keyused * <span class="number">4</span>,</span><br><span class="line">                            PY_LITTLE_ENDIAN,</span><br><span class="line">                            <span class="number">0</span>, <span class="comment">/* unsigned */</span></span><br><span class="line">                            <span class="number">1</span>); <span class="comment">/* with exceptions */</span></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> Done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_by_array(self, key, keyused);</span><br></pre></td></tr></table></figure>
<p>代码的大致逻辑是如果种子是一个正整数（无论长度多长），它会被分割为若干个32位的块以构造关键数组；如果是负整数，则使用其绝对值；如果是浮点数，则使用其<code>hash</code>值</p>
<p>利用原文章的例子介绍一下每段代码中出现的<code>key</code>数组的构造过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_into_32bit_chunks</span>(<span class="params">n</span>):</span><br><span class="line">    chunks = []</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        chunks.append(n &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">        n &gt;&gt;= <span class="number">32</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> chunks:</span><br><span class="line">        chunks = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> chunks</span><br><span class="line"></span><br><span class="line"><span class="comment"># random.seed(-0x909192939495969798)</span></span><br><span class="line">key1 = [<span class="built_in">hex</span>(chunk) <span class="keyword">for</span> chunk <span class="keyword">in</span>  split_into_32bit_chunks(<span class="built_in">abs</span>(-<span class="number">0x909192939495969798</span>))]</span><br><span class="line"><span class="built_in">print</span>(key1)</span><br><span class="line"><span class="comment"># key1 = [0x95969798, 0x91929394, 0x90]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># random.seed(0x909192939495969798)</span></span><br><span class="line">key2 = [<span class="built_in">hex</span>(chunk) <span class="keyword">for</span> chunk <span class="keyword">in</span> split_into_32bit_chunks(<span class="number">0x909192939495969798</span>)]</span><br><span class="line"><span class="built_in">print</span>(key2)</span><br><span class="line"><span class="comment"># key2 = [0x95969798, 0x91929394, 0x90]</span></span><br><span class="line"></span><br><span class="line">random.seed(<span class="built_in">hash</span>(<span class="number">871628728198271972.8621</span>))</span><br><span class="line">key3 = [chunk <span class="keyword">for</span> chunk <span class="keyword">in</span> split_into_32bit_chunks(<span class="built_in">hash</span>(<span class="number">871628728198271972.8621</span>))]</span><br><span class="line"><span class="built_in">print</span>(key3)</span><br><span class="line"><span class="comment"># key4 = [3494417408, 202941877]</span></span><br><span class="line"></span><br><span class="line">random.seed(<span class="string">&quot;my seed&quot;</span>)</span><br><span class="line">equivalent_seed = <span class="number">0x6d792073656564c046d02141256723ba893a44f1a54538aba62218287bc56767433568ca7548571fe1760ba924e2f8b1e9e8887814c985f3827c68fdb09e639f313ec1c83476be</span></span><br><span class="line">key4 = [chunk <span class="keyword">for</span> chunk <span class="keyword">in</span> split_into_32bit_chunks(equivalent_seed)]</span><br><span class="line"><span class="built_in">print</span>(key4)</span><br><span class="line"><span class="comment"># key = [3358881470, 2670804673, 4256210531, 4085415016, 2014628229, 2984896648, 2837766904, 534869515, 3396683863, 1732457832, 679200103, 2879791640, 4054140216, 3129555524, 1092970275, 3225866273, 1936024932, 7174432]</span></span><br></pre></td></tr></table></figure>
<p>之后<code>key</code>数组（即种子数组）仍然和之前一样传入 <code>init_by_array</code> 函数</p>
<p>现在我们已经了解了不同类型的种子是如何去构造<code>key</code>数组的，接下来介绍如何通过这个可变长数组计算mt的初始状态$I$，我们记<code>key</code>数组为$\mathrm{K}$，长度为$k$</p>
<h3 id="初始状态的构建"><a href="#初始状态的构建" class="headerlink" title="初始状态的构建"></a>初始状态的构建</h3><p><code>init_by_array</code>函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initialize by an array with array-length */</span></span><br><span class="line"><span class="comment">/* init_key is the array for initializing keys */</span></span><br><span class="line"><span class="comment">/* key_length is its length */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_by_array</span><span class="params">(RandomObject *self, <span class="type">uint32_t</span> init_key[], <span class="type">size_t</span> key_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i, j, k, l;       <span class="comment">/* was signed in the original code. RDH 12/16/2002 */</span></span><br><span class="line">    <span class="type">uint32_t</span> *mt;</span><br><span class="line"></span><br><span class="line">    mt = self-&gt;state;</span><br><span class="line">    init_genrand(self, <span class="number">19650218U</span>);</span><br><span class="line">    i=<span class="number">1</span>; j=<span class="number">0</span>;</span><br><span class="line">    k = (N&gt;key_length ? N : key_length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; k; k--) &#123;</span><br><span class="line">        mt[i] = (mt[i] ^ ((mt[i<span class="number">-1</span>] ^ (mt[i<span class="number">-1</span>] &gt;&gt; <span class="number">30</span>)) * <span class="number">1664525U</span>))</span><br><span class="line">                 + init_key[j] + (<span class="type">uint32_t</span>)j; <span class="comment">/* non linear */</span></span><br><span class="line">        i++; j++;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=N) &#123; mt[<span class="number">0</span>] = mt[N<span class="number">-1</span>]; i=<span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (j&gt;=key_length) j=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k=N<span class="number">-1</span>; k; k--) &#123;</span><br><span class="line">        mt[i] = (mt[i] ^ ((mt[i<span class="number">-1</span>] ^ (mt[i<span class="number">-1</span>] &gt;&gt; <span class="number">30</span>)) * <span class="number">1566083941U</span>))</span><br><span class="line">                 - (<span class="type">uint32_t</span>)i; <span class="comment">/* non linear */</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=N) &#123; mt[<span class="number">0</span>] = mt[N<span class="number">-1</span>]; i=<span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mt[<span class="number">0</span>] = <span class="number">0x80000000</span>U; <span class="comment">/* MSB is 1; assuring non-zero initial array */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它用于通过用户提供的种子数组 <code>init_key[]</code> 来初始化状态数组 <code>mt</code>，从而确定随机数序列的起点，函数需要传入三个参数：</p>
<ul>
<li>指向RandomObject结构的指针</li>
<li>初始化使用的种子数组</li>
<li>种子数组的长度</li>
</ul>
<p>接下来介绍<code>init_by_array</code>函数的逻辑：</p>
<ul>
<li>通过使用默认种子19650218调用 <code>init_genrand</code> 来初始化初始状态 <code>I</code> <ul>
<li>对mt数组引导初始化确保状态不是全 0，全 1 等不安全状态</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>init_genrand</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initializes mt[N] with a seed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_genrand</span><span class="params">(RandomObject *self, <span class="type">uint32_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mti;</span><br><span class="line"><span class="type">uint32_t</span> *mt;</span><br><span class="line"></span><br><span class="line">mt = self-&gt;state;</span><br><span class="line">mt[<span class="number">0</span>]= s;</span><br><span class="line"><span class="keyword">for</span> (mti=<span class="number">1</span>; mti&lt;N; mti++) &#123;</span><br><span class="line">    mt[mti] =</span><br><span class="line">    (<span class="number">1812433253U</span> * (mt[mti<span class="number">-1</span>] ^ (mt[mti<span class="number">-1</span>] &gt;&gt; <span class="number">30</span>)) + mti);</span><br><span class="line">    <span class="comment">/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */</span></span><br><span class="line">    <span class="comment">/* In the previous versions, MSBs of the seed affect   */</span></span><br><span class="line">    <span class="comment">/* only MSBs of the array mt[].                                */</span></span><br><span class="line">    <span class="comment">/* 2002/01/09 modified by Makoto Matsumoto                     */</span></span><br><span class="line">&#125;</span><br><span class="line">self-&gt;index = mti;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不去关注函数内部的具体实现，我们只记初始化完成的mt为$PI$</p>
</blockquote>
<ul>
<li>第一个循环是关键的初始化步骤，进行循环混合，将<code>mt</code>数组，<code>init_key</code>数组，当前索引等进行混合，实现非线性扩散，具体的操作很简单我们会在下面建模说明</li>
<li>第二个循环更改了与<code>mt</code>数组相乘的乘数，继续打乱mt状态，实现雪崩效应</li>
<li>最后一步将初始状态<code>mt</code>数组的第一个元素$I_0$置为 <code>0x80000000</code></li>
</ul>
<p>设<code>A=1664525</code>，函数$u(x)$定义如下：</p>
<script type="math/tex; mode=display">
u(x)=x\oplus (x\gg30)</script><p>第一个循环执行如下的操作：</p>
<script type="math/tex; mode=display">
\begin{array}{lrl}
J_{i}=\left(PI_{i} \oplus u\left(J_{i-1}\right) A\right)+K_{j}+j & \forall i \in[1,623], j \equiv i-1 & \bmod k \qquad(4)\\
J_{0}=J_{623} & &  \qquad \qquad \hspace{0.4cm} (5)\\
J_{1}=\left(J_{1} \oplus u\left(J_{0}\right) A\right)+K_{j}+j & j \equiv 623 & \bmod k \qquad(6)
\end{array}</script><p>==注：新中间状态 $J$ 要通过预初始化后的<code>mt</code>得到，$(2)(3)$两式出现的原因是下面的代码==</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; k; k--) &#123;</span><br><span class="line">        mt[i] = (mt[i] ^ ((mt[i<span class="number">-1</span>] ^ (mt[i<span class="number">-1</span>] &gt;&gt; <span class="number">30</span>)) * <span class="number">1664525U</span>))</span><br><span class="line">                 + init_key[j] + (<span class="type">uint32_t</span>)j; <span class="comment">/* non linear */</span></span><br><span class="line">        i++; j++;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=N) &#123; mt[<span class="number">0</span>] = mt[N<span class="number">-1</span>]; i=<span class="number">1</span>; &#125;    <span class="comment">// the code for (2)(3)</span></span><br><span class="line">        <span class="keyword">if</span> (j&gt;=key_length) j=<span class="number">0</span>;				   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先，i 和 j 同时自增，当<code>i&gt;=N</code>时，将<code>mt[0]</code>的值修改为<code>mt[623]</code>的值；当<code>j&gt;=key_length</code>时，将<code>j</code>置为0，因为循环的条件是<code>max(N,key_length)</code>，因此<code>if</code>的两个判断均能被执行，当执行完 <code>if (i&gt;=N) &#123; mt[0] = mt[N-1]; i=1; &#125;</code>之后，$J_0$状态被改变，$i$ 被重置到1，也即下一次更新的状态是$J_1$（这里的更新是在$J_1$已被更新过的基础上），那么在这一次循环中$J_1$被改变了两次，在一般情况下循环到这里就结束了。</p>
<p>那么这里<code>i</code>和<code>j</code>的作用就很明显了，<code>i</code> 控制状态数组的索引，如果 <code>i &gt;= N</code>，回绕到头部；<code>j</code> 控制 key 的索引，如果 <code>j &gt;= key_length</code>，回绕 key 数组</p>
<p>这里设<code>B = 1566083941</code>，第二个循环执行了下面的操作：</p>
<script type="math/tex; mode=display">
\begin{array}{lll}
I_{i}=(J_i\oplus u(I_{i-1})B)-i\quad\forall i\in[2,623] \qquad \mathrm{(7)} \\
I_{0}=I_{623} \qquad \qquad\qquad\qquad\qquad\qquad\qquad \hspace{0.15cm} \left(8\right) \\
I_{1}=(I_1\oplus u(I_0)B)-1 \qquad \qquad \qquad \qquad \hspace{0.2cm}\left(9\right) \\
I_{0}\text{=0x80000000} \qquad \qquad \qquad \qquad \qquad \hspace{0.45cm}\ \mathrm{(10)}
\end{array}</script><p>这里的第(7)个式子从<code>i=2</code>开始，因为<code>i=1</code>在(6)中被使用，剩下的操作基本上从代码中都能看懂</p>
<h2 id="从少量输出中恢复种子"><a href="#从少量输出中恢复种子" class="headerlink" title="从少量输出中恢复种子"></a>从少量输出中恢复种子</h2><p>假如我们现在知道了初始状态的两个连续值 $J<em>i$ 和 $J</em>{i-1}$可从(4)式写出</p>
<script type="math/tex; mode=display">
K_{j}+j=J_{i} - \left(PI_{i} \oplus u\left(J_{i-1}\right) A\right)& \forall i \in[3,623], j \equiv i-1 & \bmod k \qquad(11)\\</script><p>注：因为$(5)(6)$的原因 $i$ 要从3开始，$PI$状态的值固定</p>
<p>同时假设我们知道种子数组 $K$ 的长度 $k$ ，那么我们就能恢复索引值 $j$ （个人感觉能够恢复 $j$ 的原因是，在<code>if (j&gt;=key_length) j=0;</code>这行代码里，$j$ 和数组的长度存在关联），之后就能恢复 $K_j$ 的实际值。这样的推导是合理的，我们在上面说过 <code>key</code> 数组的 $k$ 取决于种子的类型或其长度，即使我们不知道 $k$ 的实际长度，猜测它对于我们来说也是非常容易的。</p>
<p>注：通常情况下$k\le624$</p>
<p>实现上面操作的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_genrand</span>(<span class="params">seed</span>):</span><br><span class="line">        MT = [<span class="number">0</span>] * <span class="number">624</span></span><br><span class="line">        MT[<span class="number">0</span>] = seed &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">623</span>+<span class="number">1</span>): <span class="comment"># loop over each element</span></span><br><span class="line">            MT[i] = ((<span class="number">0x6c078965</span> * (MT[i-<span class="number">1</span>] ^ (MT[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>))) + i) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">return</span> MT</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_kj_from_Ji</span>(<span class="params">ji, ji1, i</span>):</span><br><span class="line">    <span class="comment"># ji =&gt; J[i]</span></span><br><span class="line">    <span class="comment"># ji1 =&gt; J[i-1]</span></span><br><span class="line">    const = init_genrand(<span class="number">19650218</span>)</span><br><span class="line">    key = ji - (const[i] ^ ((ji1 ^ (ji1 &gt;&gt; <span class="number">30</span>))*<span class="number">1664525</span>))</span><br><span class="line">    key &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="comment"># return K[j] + j</span></span><br><span class="line">    <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们实现了中间状态 $J$ 到种子 $K$ 的逆过程，接下来寻找初始状态 $I$ 到中间状态 $J$ 的过程</p>
<p>若已知两个连续的初始状态值 $I<em>i$ 和 $I</em>{i-1}$，由$(7)$可得</p>
<script type="math/tex; mode=display">
J_i=(I_{i}+i)\oplus u(I_{i-1})B\quad\forall i\in[3,623] \quad (12)</script><p>注：由于$(9)(10)$，$i$从3开始上式才成立</p>
<p>上述操作的代码如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recover_Ji_from_Ii</span>(<span class="params">Ii, Ii1, i</span>):</span><br><span class="line">    <span class="comment"># Ii =&gt; I[i]</span></span><br><span class="line">    <span class="comment"># Ii1 =&gt; I[i-1]</span></span><br><span class="line">    ji = (Ii + i) ^ ((Ii1 ^ (Ii1 &gt;&gt; <span class="number">30</span>)) * <span class="number">1566083941</span>)</span><br><span class="line">    ji &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="comment"># return J[i]</span></span><br><span class="line">    <span class="keyword">return</span> ji</span><br></pre></td></tr></table></figure>
<p>到目前为止我们证明了两个连续的 $I$ 值可以恢复单个 $J$ 值，又证明了两个连续的 $J$ 值足以恢复 $K$ 值，如原文配图所示</p>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250507221432.png" alt="微信截图_20250507221432"></p>
<p>上图的过程用代码写出即</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recover_Kj_from_Ii</span>(<span class="params">Ii, Ii1, Ii2, i</span>):</span><br><span class="line">    <span class="comment"># Ii =&gt; I[i]</span></span><br><span class="line">    <span class="comment"># Ii1 =&gt; I[i-1]</span></span><br><span class="line">    <span class="comment"># Ii2 =&gt; I[i-2]</span></span><br><span class="line">    <span class="comment"># Ji =&gt; J[i]</span></span><br><span class="line">    <span class="comment"># Ji1 =&gt; J[i-1]</span></span><br><span class="line">    Ji = recover_Ji_from_Ii(Ii, Ii1, i)</span><br><span class="line">    Ji1 = recover_Ji_from_Ii(Ii1, Ii2, i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> recover_kj_from_Ji(Ji, Ji1, i)</span><br></pre></td></tr></table></figure>
<p>上述的恢复过程在$\forall i \in[4,623] $下才成立</p>
<p>完整POC</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_genrand</span>(<span class="params">seed</span>):</span><br><span class="line">    MT = [<span class="number">0</span>] * <span class="number">624</span></span><br><span class="line">    MT[<span class="number">0</span>] = seed &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">623</span> + <span class="number">1</span>):  <span class="comment"># loop over each element</span></span><br><span class="line">        MT[i] = ((<span class="number">0x6c078965</span> * (MT[i - <span class="number">1</span>] ^ (MT[i - <span class="number">1</span>] &gt;&gt; <span class="number">30</span>))) + i) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">return</span> MT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_kj_from_Ji</span>(<span class="params">ji, ji1, i</span>):</span><br><span class="line">    <span class="comment"># ji =&gt; J[i]</span></span><br><span class="line">    <span class="comment"># ji1 =&gt; J[i-1]</span></span><br><span class="line">    const = init_genrand(<span class="number">19650218</span>)</span><br><span class="line">    key = ji - (const[i] ^ ((ji1 ^ (ji1 &gt;&gt; <span class="number">30</span>)) * <span class="number">1664525</span>))</span><br><span class="line">    key &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="comment"># return K[j] + j</span></span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_Ji_from_Ii</span>(<span class="params">Ii, Ii1, i</span>):</span><br><span class="line">    <span class="comment"># Ii =&gt; I[i]</span></span><br><span class="line">    <span class="comment"># Ii1 =&gt; I[i-1]</span></span><br><span class="line">    ji = (Ii + i) ^ ((Ii1 ^ (Ii1 &gt;&gt; <span class="number">30</span>)) * <span class="number">1566083941</span>)</span><br><span class="line">    ji &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="comment"># return J[i]</span></span><br><span class="line">    <span class="keyword">return</span> ji</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_Kj_from_Ii</span>(<span class="params">Ii, Ii1, Ii2, i</span>):</span><br><span class="line">    <span class="comment"># Ii =&gt; I[i]</span></span><br><span class="line">    <span class="comment"># Ii1 =&gt; I[i-1]</span></span><br><span class="line">    <span class="comment"># Ii2 =&gt; I[i-2]</span></span><br><span class="line">    <span class="comment"># Ji =&gt; J[i]</span></span><br><span class="line">    <span class="comment"># Ji1 =&gt; J[i-1]</span></span><br><span class="line">    Ji = recover_Ji_from_Ii(Ii, Ii1, i)</span><br><span class="line">    Ji1 = recover_Ji_from_Ii(Ii1, Ii2, i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> recover_kj_from_Ji(Ji, Ji1, i)</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">12345</span>)</span><br><span class="line"><span class="comment"># K = [12345]</span></span><br><span class="line"><span class="comment"># k = 1</span></span><br><span class="line"></span><br><span class="line">I = random.getstate()[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">624</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, recover_Kj_from_Ii(I[i], I[i-<span class="number">1</span>], I[i-<span class="number">2</span>], i))</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250507221936.png" alt="微信截图_20250507221936"></p>
<p>在上面我们提到知道当前状态的一对值 $(S<em>i,\ S</em>{i+227})$ 可以恢复 $I<em>{i+228}$ 的低31位以及 $I</em>{i+227}$ 的最高位，那么现在如果知道了另一对状态的值 $(S<em>{i+1},\ S</em>{i+228})$，我们能够恢复 $I<em>{i+229}$ 的低31位以及 $I</em>{i+228}$ 的最高位，那么此时我们就能获得 $I_{i+228}$ 的精确数值</p>
<p>那么现在继续添加一组会发生什么？添加 $(S<em>{i+2},\ S</em>{i+229})$，我们恢复 $I<em>{i+230}$ 的低31位以及 $I</em>{i+229}$ 的最高位，我们又知道了一个当前状态 $I<em>{i+229}$ 的精确值，那么现在我们有状态 $I</em>{i+228}$，$I<em>{i+229}$，$I</em>{i+230}$的低31位，我们就可以说我们拥有了3个初始状态连续值，我们又可以利用这种方式恢复两个$K<em>j$的潜在值了（因为$I</em>{i+230}$最高位值不确定）</p>
<p>==注：$I_{i+230}$ 的MSB只影响 $K_j$ 的MSB==</p>
<p>如果Python的PRNG使用一个 32 位整数进行手动播种，那么只需要前 624 个输出中的任意 6 个，就可以恢复出该种子。</p>
<p>下面是验证代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftRight</span>(<span class="params">x, shift</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ res &gt;&gt; shift</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftLeft</span>(<span class="params">x, shift, mask</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ (res &lt;&lt; shift &amp; mask)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">v</span>):</span><br><span class="line">    v = unshiftRight(v, <span class="number">18</span>)</span><br><span class="line">    v = unshiftLeft(v, <span class="number">15</span>, <span class="number">0xefc60000</span>)</span><br><span class="line">    v = unshiftLeft(v, <span class="number">7</span>, <span class="number">0x9d2c5680</span>)</span><br><span class="line">    v = unshiftRight(v, <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invertStep</span>(<span class="params">si, si227</span>):</span><br><span class="line">    <span class="comment"># S[i] ^ S[i-227] == (((I[i] &amp; 0x80000000) | (I[i+1] &amp; 0x7FFFFFFF)) &gt;&gt; 1) ^ (0x9908b0df if I[i+1] &amp; 1 else 0)</span></span><br><span class="line">    X = si ^ si227</span><br><span class="line">    <span class="comment"># we know the LSB of I[i+1] because MSB of 0x9908b0df is set, we can see if the XOR has been applied</span></span><br><span class="line">    mti1 = (X &amp; <span class="number">0x80000000</span>) &gt;&gt; <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> mti1:</span><br><span class="line">        X ^= <span class="number">0x9908b0df</span></span><br><span class="line">    <span class="comment"># undo shift right</span></span><br><span class="line">    X &lt;&lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment"># now recover MSB of state I[i]</span></span><br><span class="line">    mti = X &amp; <span class="number">0x80000000</span></span><br><span class="line">    <span class="comment"># recover the rest of state I[i+1]</span></span><br><span class="line">    mti1 += X &amp; <span class="number">0x7FFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> mti, mti1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_genrand</span>(<span class="params">seed</span>):</span><br><span class="line">    MT = [<span class="number">0</span>] * <span class="number">624</span></span><br><span class="line">    MT[<span class="number">0</span>] = seed &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">623</span> + <span class="number">1</span>):  <span class="comment"># loop over each element</span></span><br><span class="line">        MT[i] = ((<span class="number">0x6c078965</span> * (MT[i - <span class="number">1</span>] ^ (MT[i - <span class="number">1</span>] &gt;&gt; <span class="number">30</span>))) + i) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">return</span> MT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_kj_from_Ji</span>(<span class="params">ji, ji1, i</span>):</span><br><span class="line">    <span class="comment"># ji =&gt; J[i]</span></span><br><span class="line">    <span class="comment"># ji1 =&gt; J[i-1]</span></span><br><span class="line">    const = init_genrand(<span class="number">19650218</span>)</span><br><span class="line">    key = ji - (const[i] ^ ((ji1 ^ (ji1 &gt;&gt; <span class="number">30</span>)) * <span class="number">1664525</span>))</span><br><span class="line">    key &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="comment"># return K[j] + j</span></span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_Ji_from_Ii</span>(<span class="params">Ii, Ii1, i</span>):</span><br><span class="line">    <span class="comment"># Ii =&gt; I[i]</span></span><br><span class="line">    <span class="comment"># Ii1 =&gt; I[i-1]</span></span><br><span class="line">    ji = (Ii + i) ^ ((Ii1 ^ (Ii1 &gt;&gt; <span class="number">30</span>)) * <span class="number">1566083941</span>)</span><br><span class="line">    ji &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="comment"># return J[i]</span></span><br><span class="line">    <span class="keyword">return</span> ji</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recover_Kj_from_Ii</span>(<span class="params">Ii, Ii1, Ii2, i</span>):</span><br><span class="line">    <span class="comment"># Ii =&gt; I[i]</span></span><br><span class="line">    <span class="comment"># Ii1 =&gt; I[i-1]</span></span><br><span class="line">    <span class="comment"># Ii2 =&gt; I[i-2]</span></span><br><span class="line">    <span class="comment"># Ji =&gt; J[i]</span></span><br><span class="line">    <span class="comment"># Ji1 =&gt; J[i-1]</span></span><br><span class="line">    Ji = recover_Ji_from_Ii(Ii, Ii1, i)</span><br><span class="line">    Ji1 = recover_Ji_from_Ii(Ii1, Ii2, i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> recover_kj_from_Ji(Ji, Ji1, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    random.seed(i)</span><br><span class="line">    <span class="comment"># k = 1</span></span><br><span class="line">    <span class="comment"># K = [i]</span></span><br><span class="line"></span><br><span class="line">    S = [untemper(random.getrandbits(<span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>)]</span><br><span class="line"></span><br><span class="line">    I_227_, I_228 = invertStep(S[<span class="number">0</span>], S[<span class="number">227</span>])</span><br><span class="line">    I_228_, I_229 = invertStep(S[<span class="number">1</span>], S[<span class="number">228</span>])</span><br><span class="line">    I_229_, I_230 = invertStep(S[<span class="number">2</span>], S[<span class="number">229</span>])</span><br><span class="line"></span><br><span class="line">    I_228 += I_228_</span><br><span class="line">    I_229 += I_229_</span><br><span class="line"></span><br><span class="line">    <span class="comment"># two possibilities for I_230</span></span><br><span class="line">    seed1 = recover_Kj_from_Ii(I_230, I_229, I_228, <span class="number">230</span>)</span><br><span class="line">    seed2 = recover_Kj_from_Ii(I_230+<span class="number">0x80000000</span>, I_229, I_228, <span class="number">230</span>)</span><br><span class="line">    <span class="comment"># only the MSB differs</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(seed1), <span class="built_in">hex</span>(seed2))</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250508170455.png" alt="微信截图_20250508170455"></p>
<p>上面我们所讨论的是恢复单个32位整数种子的推导过程，那么对于这种情况来说种子数组的长度是 $k=1$，如果现在种子数组的长度是2呢？回想上面我们已经获得3个连续的初始状态，如果现在再利用一对当前状态反推出一组初始状态的 MSB 和低31位，我们就能继续恢复整个数组，无论恢复多少个初始状态只有$I_i$的MSB会缺失，因此这个状态都会存在两个值，这也就导致$K_j$存在两个可能的值</p>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250508172831.png" alt="微信截图_20250508172831"></p>
<p>原文章给出了在每种情形下恢复种子所需的最小输出数量，如下所示：</p>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250508173112.png" alt="微信截图_20250508173112"></p>
<p>下面我们将探究一个特殊的情况，$k=624$，这种情况下我们只需要624个输出即可完成种子的恢复，因为随着关系对的不断加入，我们可以在他们之间建立更多的关系，从而降低恢复种子所需要的输出。</p>
<h2 id="从完整状态恢复种子"><a href="#从完整状态恢复种子" class="headerlink" title="从完整状态恢复种子"></a>从完整状态恢复种子</h2><p>状态更新操作可逆，知道完整的状态就足以从任何状态$S$倒回 初始状态$I$</p>
<p>状态更新过程中仅使用了$I_0$的MSB，其他位均未被使用，因此我们无法去恢复这些确切的位，因为这个原因回溯后的状态在第一个值上将会有所不同</p>
<p>下面代码基于$(1)(2)(3)$实现了倒带过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rewindState</span>(<span class="params">state</span>):</span><br><span class="line">    prev = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">    <span class="comment"># copy to not modify input array</span></span><br><span class="line">    s = state[:]</span><br><span class="line">    I, I0 = invertStep(s[<span class="number">623</span>], s[<span class="number">396</span>])</span><br><span class="line">    prev[<span class="number">623</span>] += I</span><br><span class="line">    <span class="comment"># update state 0</span></span><br><span class="line">    <span class="comment"># this does nothing when working with a known full state, but is important we rewinding more than 1 time</span></span><br><span class="line">    s[<span class="number">0</span>] = (s[<span class="number">0</span>]&amp;<span class="number">0x80000000</span>) + I0</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">227</span>, <span class="number">623</span>):</span><br><span class="line">        I, I1 = invertStep(s[i], s[i-<span class="number">227</span>])</span><br><span class="line">        prev[i] += I</span><br><span class="line">        prev[i+<span class="number">1</span>] += I1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">227</span>):</span><br><span class="line">        I, I1 = invertStep(s[i], prev[i+<span class="number">397</span>])</span><br><span class="line">        prev[i] += I</span><br><span class="line">        prev[i+<span class="number">1</span>] += I1</span><br><span class="line">    <span class="comment"># The LSBs of prev[0] do not matter, they are 0 here</span></span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>
<p>上面的代码实际上利用所有生成的当前状态去反推初始状态，逻辑还是很简单的</p>
<p>下面是POC</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftRight</span>(<span class="params">x, shift</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ res &gt;&gt; shift</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unshiftLeft</span>(<span class="params">x, shift, mask</span>):</span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        res = x ^ (res &lt;&lt; shift &amp; mask)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">v</span>):</span><br><span class="line">    v = unshiftRight(v, <span class="number">18</span>)</span><br><span class="line">    v = unshiftLeft(v, <span class="number">15</span>, <span class="number">0xefc60000</span>)</span><br><span class="line">    v = unshiftLeft(v, <span class="number">7</span>, <span class="number">0x9d2c5680</span>)</span><br><span class="line">    v = unshiftRight(v, <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invertStep</span>(<span class="params">si, si227</span>):</span><br><span class="line">    <span class="comment"># S[i] ^ S[i-227] == (((I[i] &amp; 0x80000000) | (I[i+1] &amp; 0x7FFFFFFF)) &gt;&gt; 1) ^ (0x9908b0df if I[i+1] &amp; 1 else 0)</span></span><br><span class="line">    X = si ^ si227</span><br><span class="line">    <span class="comment"># we know the LSB of I[i+1] because MSB of 0x9908b0df is set, we can see if the XOR has been applied</span></span><br><span class="line">    mti1 = (X &amp; <span class="number">0x80000000</span>) &gt;&gt; <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> mti1:</span><br><span class="line">        X ^= <span class="number">0x9908b0df</span></span><br><span class="line">    <span class="comment"># undo shift right</span></span><br><span class="line">    X &lt;&lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment"># now recover MSB of state I[i]</span></span><br><span class="line">    mti = X &amp; <span class="number">0x80000000</span></span><br><span class="line">    <span class="comment"># recover the rest of state I[i+1]</span></span><br><span class="line">    mti1 += X &amp; <span class="number">0x7FFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> mti, mti1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rewindState</span>(<span class="params">state</span>):</span><br><span class="line">    prev = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">    <span class="comment"># copy to not modify input array</span></span><br><span class="line">    s = state[:]</span><br><span class="line">    I, I0 = invertStep(s[<span class="number">623</span>], s[<span class="number">396</span>])</span><br><span class="line">    prev[<span class="number">623</span>] += I</span><br><span class="line">    <span class="comment"># update state 0</span></span><br><span class="line">    <span class="comment"># this does nothing when working with a known full state, but is important we rewinding more than 1 time</span></span><br><span class="line">    s[<span class="number">0</span>] = (s[<span class="number">0</span>]&amp;<span class="number">0x80000000</span>) + I0</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">227</span>, <span class="number">623</span>):</span><br><span class="line">        I, I1 = invertStep(s[i], s[i-<span class="number">227</span>])</span><br><span class="line">        prev[i] += I</span><br><span class="line">        prev[i+<span class="number">1</span>] += I1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">227</span>):</span><br><span class="line">        I, I1 = invertStep(s[i], prev[i+<span class="number">397</span>])</span><br><span class="line">        prev[i] += I</span><br><span class="line">        prev[i+<span class="number">1</span>] += I1</span><br><span class="line">    <span class="comment"># The LSBs of prev[0] do not matter, they are 0 here</span></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">I = <span class="built_in">list</span>(random.getstate()[<span class="number">1</span>][:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">S1 = [untemper(random.getrandbits(<span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>)]</span><br><span class="line">S2 = [untemper(random.getrandbits(<span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>)]</span><br><span class="line">S3 = [untemper(random.getrandbits(<span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># rewind once</span></span><br><span class="line">I_ = rewindState(S1)</span><br><span class="line">S2_ = rewindState(S3)</span><br><span class="line">S1_ = rewindState(S2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(I_ == I)</span><br><span class="line"><span class="built_in">print</span>(S1_[<span class="number">1</span>:] == S1[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(S2_[<span class="number">1</span>:] == S2[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># rewind multiple times</span></span><br><span class="line">I_ = rewindState(rewindState(rewindState(S3)))</span><br><span class="line"><span class="built_in">print</span>(I_ == I)</span><br><span class="line"><span class="built_in">print</span>(I_[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(I[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250508182451.png" alt="微信截图_20250508182451"></p>
<p>执行完上面的POC之后我们恢复了完整的初始状态，接下来就是恢复种子，我们将利用下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seedArrayFromState</span>(<span class="params">s, subtractIndices=<span class="literal">True</span></span>):</span><br><span class="line">    s_ = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">623</span>, <span class="number">2</span>, -<span class="number">1</span>):</span><br><span class="line">        s_[i] = recover_Ji_from_Ii(s[i], s[i-<span class="number">1</span>], i)</span><br><span class="line">    s_[<span class="number">0</span>]=s_[<span class="number">623</span>]</span><br><span class="line">    s_[<span class="number">1</span>]=recover_Ji_from_Ii(s[<span class="number">1</span>], s[<span class="number">623</span>],  <span class="number">1</span>)</span><br><span class="line">    s_[<span class="number">2</span>]=recover_Ji_from_Ii(s[<span class="number">2</span>], s_[<span class="number">1</span>], <span class="number">2</span>)</span><br><span class="line">    seed = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">623</span>, <span class="number">2</span>, -<span class="number">1</span>):</span><br><span class="line">        seed[i-<span class="number">1</span>] = recover_kj_from_Ji(s_[i], s_[i-<span class="number">1</span>], i)</span><br><span class="line">    <span class="comment"># system overdefined for seed[0,1,623]</span></span><br><span class="line">    seed[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># thus s1 = (const[1] ^ ((const[0] ^ (const[0] &gt;&gt; 30))*1664525))</span></span><br><span class="line">    s1_old = ((<span class="number">2194844435</span> ^ ((<span class="number">19650218</span> ^ (<span class="number">19650218</span> &gt;&gt; <span class="number">30</span>))*<span class="number">1664525</span>))) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    seed[<span class="number">1</span>] = recover_kj_from_Ji(s_[<span class="number">2</span>], s1_old, <span class="number">2</span>)</span><br><span class="line">    seed[<span class="number">623</span>] = (s_[<span class="number">1</span>] - (s1_old ^ ((s_[<span class="number">0</span>] ^ (s_[<span class="number">0</span>] &gt;&gt; <span class="number">30</span>))*<span class="number">1664525</span>))) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="comment"># subtract the j indices</span></span><br><span class="line">    <span class="keyword">if</span> subtractIndices:</span><br><span class="line">        seed = [(<span class="number">2</span>**<span class="number">32</span>+e-i)%<span class="number">2</span>**<span class="number">32</span> <span class="keyword">for</span> i,e <span class="keyword">in</span> <span class="built_in">enumerate</span>(seed)]</span><br><span class="line">    <span class="keyword">return</span> seed</span><br></pre></td></tr></table></figure>
<p>但是 <code>init_by_array</code> 函数执行种子初始化操作的方式导致了不同的<code>init_key</code>数组可能会生成出相同的初始化状态$I$，即种子与初始化状态不是一一对应的，这就造成了种子冲突的可能性</p>
<p>这里原文章中提出了一种解决方案，我们可以固定$K_0$为一个数，这样使得我们反推<code>init_key</code>时简化解空间，实现种子恢复的唯一性，这里其实也好理解就相当于一个不定方程$x+y=10$，我们存在非常多种可能解，我们这里固定$x=0$，那么 $y=10$ ，即我们从大量的可能中选择一个作为我们的结果，这里原文章选择固定$K_0=0$</p>
<p>实现这一过程的POC如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">seedArrayToInt</span>(<span class="params">s</span>):</span><br><span class="line">    seed = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> s[::-<span class="number">1</span>]:</span><br><span class="line">        seed += e</span><br><span class="line">        seed &lt;&lt;= <span class="number">32</span></span><br><span class="line">    <span class="keyword">return</span> seed &gt;&gt; <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># random is not manually seeded so it uses 624 random values</span></span><br><span class="line"></span><br><span class="line">S = [untemper(random.getrandbits(<span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>)]</span><br><span class="line">I = rewindState(S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Normal run :&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.randbytes(<span class="number">4</span>).<span class="built_in">hex</span>())</span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nReseeded run :&quot;</span>)</span><br><span class="line"></span><br><span class="line">seed_array = seedArrayFromState(I)</span><br><span class="line">seed = seedArrayToInt(seed_array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># the recovered seed is very big. Too big to be printed in decimal</span></span><br><span class="line"><span class="comment"># print(hex(seed))</span></span><br><span class="line">random.seed(seed)</span><br><span class="line"></span><br><span class="line">S_ = [untemper(random.getrandbits(<span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(S_ == S)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.randbytes(<span class="number">4</span>).<span class="built_in">hex</span>())</span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>, <span class="number">100000</span>))</span><br></pre></td></tr></table></figure>
<p>上述的假设建立在<strong>已知的 624 个连续输出要么是直接在种子初始化操作之后生成的，要么与其之间相隔了 624 的倍数个输出</strong></p>
<p><img src="/2025/05/08/PRNG-MT19937%E5%88%86%E6%9E%90/微信截图_20250508194110.png" alt="微信截图_20250508194110"></p>

    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by Chromos2me, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
        <p class="tags">
            
            <i class="icon"></i>
            <a href="/tags/MT19937/" class="tag">#MT19937</a><a href="/tags/PRNG/" class="tag">#PRNG</a>
        </p>
        
    </div>
    

    <div class="container post-prev-next">
        <a class="next"></a>
        
        <a href="/2025/04/27/HTB-Machine-Coder/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">HTB-Machine-Coder</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/about" class="item">About</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/Chromos2me" class="item">GitHub</a>
                
                <a href="3079749425@qq.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2025 Chromos2me<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>